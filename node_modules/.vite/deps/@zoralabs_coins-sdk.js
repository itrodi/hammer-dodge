import {
  parseEther,
  parseEventLogs,
  zeroAddress
} from "./chunk-3TGRCY6W.js";
import {
  base,
  baseSepolia
} from "./chunk-5JZ2CH2U.js";
import "./chunk-QLTFNQTE.js";
import "./chunk-2WIN36AU.js";
import "./chunk-5ZFDVHD7.js";
import {
  erc20Abi,
  isAddressEqual
} from "./chunk-YW4FBDBD.js";
import {
  formatEther
} from "./chunk-QE3ABQVW.js";
import "./chunk-JYB5W2LJ.js";
import {
  __publicField
} from "./chunk-UVKRO5ER.js";

// node_modules/@zoralabs/coins/dist/index.js
var coinABI = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_protocolRewardRecipient",
        internalType: "address",
        type: "address"
      },
      { name: "_protocolRewards", internalType: "address", type: "address" },
      { name: "_weth", internalType: "address", type: "address" },
      {
        name: "_nonfungiblePositionManager",
        internalType: "address",
        type: "address"
      },
      { name: "_swapRouter", internalType: "address", type: "address" }
    ],
    stateMutability: "nonpayable"
  },
  { type: "receive", stateMutability: "payable" },
  {
    type: "function",
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "MAX_TOTAL_SUPPLY",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "MIN_ORDER_SIZE",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "PLATFORM_REFERRER_FEE_BPS",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "PROTOCOL_FEE_BPS",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "TOKEN_CREATOR_FEE_BPS",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "TOTAL_FEE_BPS",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "TRADE_REFERRER_FEE_BPS",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "WETH",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "addOwner",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "accounts", internalType: "address[]", type: "address[]" }
    ],
    name: "addOwners",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "owner", internalType: "address", type: "address" },
      { name: "spender", internalType: "address", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "spender", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", internalType: "bool", type: "bool" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [{ name: "amount", internalType: "uint256", type: "uint256" }],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "recipient", internalType: "address", type: "address" },
      { name: "orderSize", internalType: "uint256", type: "uint256" },
      { name: "minAmountOut", internalType: "uint256", type: "uint256" },
      { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" },
      { name: "tradeReferrer", internalType: "address", type: "address" }
    ],
    name: "buy",
    outputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "uint256", type: "uint256" }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    inputs: [{ name: "pushEthRewards", internalType: "bool", type: "bool" }],
    name: "claimSecondaryRewards",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "contractURI",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "contractVersion",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "pure"
  },
  {
    type: "function",
    inputs: [],
    name: "currency",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", internalType: "bytes1", type: "bytes1" },
      { name: "name", internalType: "string", type: "string" },
      { name: "version", internalType: "string", type: "string" },
      { name: "chainId", internalType: "uint256", type: "uint256" },
      { name: "verifyingContract", internalType: "address", type: "address" },
      { name: "salt", internalType: "bytes32", type: "bytes32" },
      { name: "extensions", internalType: "uint256[]", type: "uint256[]" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "payoutRecipient_", internalType: "address", type: "address" },
      { name: "owners_", internalType: "address[]", type: "address[]" },
      { name: "tokenURI_", internalType: "string", type: "string" },
      { name: "name_", internalType: "string", type: "string" },
      { name: "symbol_", internalType: "string", type: "string" },
      { name: "platformReferrer_", internalType: "address", type: "address" },
      { name: "currency_", internalType: "address", type: "address" },
      { name: "tickLower_", internalType: "int24", type: "int24" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "isOwner",
    outputs: [{ name: "", internalType: "bool", type: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "lpTokenId",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "name",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [{ name: "owner", internalType: "address", type: "address" }],
    name: "nonces",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "nonfungiblePositionManager",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "bytes", type: "bytes" }
    ],
    name: "onERC721Received",
    outputs: [{ name: "", internalType: "bytes4", type: "bytes4" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "owners",
    outputs: [{ name: "", internalType: "address[]", type: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "payoutRecipient",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "owner", internalType: "address", type: "address" },
      { name: "spender", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "v", internalType: "uint8", type: "uint8" },
      { name: "r", internalType: "bytes32", type: "bytes32" },
      { name: "s", internalType: "bytes32", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "platformReferrer",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "poolAddress",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "protocolRewardRecipient",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "protocolRewards",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "removeOwner",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "accounts", internalType: "address[]", type: "address[]" }
    ],
    name: "removeOwners",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "revokeOwnership",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "recipient", internalType: "address", type: "address" },
      { name: "orderSize", internalType: "uint256", type: "uint256" },
      { name: "minAmountOut", internalType: "uint256", type: "uint256" },
      { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" },
      { name: "tradeReferrer", internalType: "address", type: "address" }
    ],
    name: "sell",
    outputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "uint256", type: "uint256" }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [{ name: "newURI", internalType: "string", type: "string" }],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "newPayoutRecipient", internalType: "address", type: "address" }
    ],
    name: "setPayoutRecipient",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }],
    stateMutability: "pure"
  },
  {
    type: "function",
    inputs: [],
    name: "swapRouter",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "tokenURI",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", internalType: "bool", type: "bool" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "from", internalType: "address", type: "address" },
      { name: "to", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", internalType: "bool", type: "bool" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "amount0Delta", internalType: "int256", type: "int256" },
      { name: "amount1Delta", internalType: "int256", type: "int256" },
      { name: "", internalType: "bytes", type: "bytes" }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "owner",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "spender",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "value",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      }
    ],
    name: "Approval"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "buyer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "recipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "tradeReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "coinsPurchased",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "currency",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "amountFee",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "amountSold",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      }
    ],
    name: "CoinBuy"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "payoutRecipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "platformReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "protocolRewardRecipient",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "currency",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "marketRewards",
        internalType: "struct ICoin.MarketRewards",
        type: "tuple",
        components: [
          {
            name: "totalAmountCurrency",
            internalType: "uint256",
            type: "uint256"
          },
          { name: "totalAmountCoin", internalType: "uint256", type: "uint256" },
          {
            name: "creatorPayoutAmountCurrency",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "creatorPayoutAmountCoin",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "platformReferrerAmountCurrency",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "platformReferrerAmountCoin",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "protocolAmountCurrency",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "protocolAmountCoin",
            internalType: "uint256",
            type: "uint256"
          }
        ],
        indexed: false
      }
    ],
    name: "CoinMarketRewards"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "caller",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "prevRecipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "newRecipient",
        internalType: "address",
        type: "address",
        indexed: true
      }
    ],
    name: "CoinPayoutRecipientUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "seller",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "recipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "tradeReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "coinsSold",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "currency",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "amountFee",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "amountPurchased",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      }
    ],
    name: "CoinSell"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "payoutRecipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "platformReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "tradeReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "protocolRewardRecipient",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "creatorReward",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "platformReferrerReward",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "traderReferrerReward",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "protocolReward",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "currency",
        internalType: "address",
        type: "address",
        indexed: false
      }
    ],
    name: "CoinTradeRewards"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "sender",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "recipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "amount",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "senderBalance",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      },
      {
        name: "recipientBalance",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      }
    ],
    name: "CoinTransfer"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "caller",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "newURI",
        internalType: "string",
        type: "string",
        indexed: false
      },
      { name: "name", internalType: "string", type: "string", indexed: false }
    ],
    name: "ContractMetadataUpdated"
  },
  { type: "event", anonymous: false, inputs: [], name: "ContractURIUpdated" },
  { type: "event", anonymous: false, inputs: [], name: "EIP712DomainChanged" },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "version",
        internalType: "uint64",
        type: "uint64",
        indexed: false
      }
    ],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "caller",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "prevOwner",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "newOwner",
        internalType: "address",
        type: "address",
        indexed: true
      }
    ],
    name: "OwnerUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "from", internalType: "address", type: "address", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true },
      {
        name: "value",
        internalType: "uint256",
        type: "uint256",
        indexed: false
      }
    ],
    name: "Transfer"
  },
  {
    type: "error",
    inputs: [{ name: "target", internalType: "address", type: "address" }],
    name: "AddressEmptyCode"
  },
  {
    type: "error",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "AddressInsufficientBalance"
  },
  { type: "error", inputs: [], name: "AddressZero" },
  { type: "error", inputs: [], name: "AlreadyOwner" },
  { type: "error", inputs: [], name: "ECDSAInvalidSignature" },
  {
    type: "error",
    inputs: [{ name: "length", internalType: "uint256", type: "uint256" }],
    name: "ECDSAInvalidSignatureLength"
  },
  {
    type: "error",
    inputs: [{ name: "s", internalType: "bytes32", type: "bytes32" }],
    name: "ECDSAInvalidSignatureS"
  },
  {
    type: "error",
    inputs: [
      { name: "spender", internalType: "address", type: "address" },
      { name: "allowance", internalType: "uint256", type: "uint256" },
      { name: "needed", internalType: "uint256", type: "uint256" }
    ],
    name: "ERC20InsufficientAllowance"
  },
  {
    type: "error",
    inputs: [
      { name: "sender", internalType: "address", type: "address" },
      { name: "balance", internalType: "uint256", type: "uint256" },
      { name: "needed", internalType: "uint256", type: "uint256" }
    ],
    name: "ERC20InsufficientBalance"
  },
  {
    type: "error",
    inputs: [{ name: "approver", internalType: "address", type: "address" }],
    name: "ERC20InvalidApprover"
  },
  {
    type: "error",
    inputs: [{ name: "receiver", internalType: "address", type: "address" }],
    name: "ERC20InvalidReceiver"
  },
  {
    type: "error",
    inputs: [{ name: "sender", internalType: "address", type: "address" }],
    name: "ERC20InvalidSender"
  },
  {
    type: "error",
    inputs: [{ name: "spender", internalType: "address", type: "address" }],
    name: "ERC20InvalidSpender"
  },
  { type: "error", inputs: [], name: "ERC20TransferAmountMismatch" },
  {
    type: "error",
    inputs: [{ name: "deadline", internalType: "uint256", type: "uint256" }],
    name: "ERC2612ExpiredSignature"
  },
  {
    type: "error",
    inputs: [
      { name: "signer", internalType: "address", type: "address" },
      { name: "owner", internalType: "address", type: "address" }
    ],
    name: "ERC2612InvalidSigner"
  },
  { type: "error", inputs: [], name: "EthAmountMismatch" },
  { type: "error", inputs: [], name: "EthAmountTooSmall" },
  { type: "error", inputs: [], name: "EthTransferFailed" },
  { type: "error", inputs: [], name: "EthTransferInvalid" },
  { type: "error", inputs: [], name: "FailedInnerCall" },
  { type: "error", inputs: [], name: "InitialOrderSizeTooLarge" },
  { type: "error", inputs: [], name: "InsufficientFunds" },
  { type: "error", inputs: [], name: "InsufficientLiquidity" },
  {
    type: "error",
    inputs: [
      { name: "account", internalType: "address", type: "address" },
      { name: "currentNonce", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidAccountNonce"
  },
  { type: "error", inputs: [], name: "InvalidCurrencyLowerTick" },
  { type: "error", inputs: [], name: "InvalidInitialization" },
  { type: "error", inputs: [], name: "InvalidMarketType" },
  { type: "error", inputs: [], name: "InvalidWethLowerTick" },
  { type: "error", inputs: [], name: "MarketAlreadyGraduated" },
  { type: "error", inputs: [], name: "MarketNotGraduated" },
  { type: "error", inputs: [], name: "NotInitializing" },
  { type: "error", inputs: [], name: "NotOwner" },
  { type: "error", inputs: [], name: "OneOwnerRequired" },
  { type: "error", inputs: [], name: "OnlyOwner" },
  { type: "error", inputs: [], name: "OnlyPool" },
  { type: "error", inputs: [], name: "OnlyWeth" },
  { type: "error", inputs: [], name: "OwnerCannotBeAddressZero" },
  { type: "error", inputs: [], name: "ReentrancyGuardReentrantCall" },
  {
    type: "error",
    inputs: [{ name: "token", internalType: "address", type: "address" }],
    name: "SafeERC20FailedOperation"
  },
  { type: "error", inputs: [], name: "SlippageBoundsExceeded" },
  { type: "error", inputs: [], name: "UseRevokeOwnershipToRemoveSelf" }
];
var iUniswapV3PoolABI = [
  {
    type: "function",
    inputs: [],
    name: "feeGrowthGlobal0X128",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "feeGrowthGlobal1X128",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "slot0",
    outputs: [
      {
        name: "slot0",
        internalType: "struct IUniswapV3Pool.Slot0",
        type: "tuple",
        components: [
          { name: "sqrtPriceX96", internalType: "uint160", type: "uint160" },
          { name: "tick", internalType: "int24", type: "int24" },
          { name: "observationIndex", internalType: "uint16", type: "uint16" },
          {
            name: "observationCardinality",
            internalType: "uint16",
            type: "uint16"
          },
          {
            name: "observationCardinalityNext",
            internalType: "uint16",
            type: "uint16"
          },
          { name: "feeProtocol", internalType: "uint8", type: "uint8" },
          { name: "unlocked", internalType: "bool", type: "bool" }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "recipient", internalType: "address", type: "address" },
      { name: "zeroForOne", internalType: "bool", type: "bool" },
      { name: "amountSpecified", internalType: "int256", type: "int256" },
      { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "swap",
    outputs: [
      { name: "amount0", internalType: "int256", type: "int256" },
      { name: "amount1", internalType: "int256", type: "int256" }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "token0",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "token1",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "nonpayable"
  }
];
var zoraFactoryImplABI = [
  {
    type: "constructor",
    inputs: [{ name: "_coinImpl", internalType: "address", type: "address" }],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ name: "", internalType: "string", type: "string" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "coinImpl",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "payoutRecipient", internalType: "address", type: "address" },
      { name: "owners", internalType: "address[]", type: "address[]" },
      { name: "uri", internalType: "string", type: "string" },
      { name: "name", internalType: "string", type: "string" },
      { name: "symbol", internalType: "string", type: "string" },
      { name: "platformReferrer", internalType: "address", type: "address" },
      { name: "currency", internalType: "address", type: "address" },
      { name: "tickLower", internalType: "int24", type: "int24" },
      { name: "orderSize", internalType: "uint256", type: "uint256" }
    ],
    name: "deploy",
    outputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "uint256", type: "uint256" }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    inputs: [],
    name: "implementation",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [
      { name: "initialOwner", internalType: "address", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [],
    name: "owner",
    outputs: [{ name: "", internalType: "address", type: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [{ name: "newOwner", internalType: "address", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    inputs: [
      { name: "newImplementation", internalType: "address", type: "address" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "caller",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "payoutRecipient",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "platformReferrer",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "currency",
        internalType: "address",
        type: "address",
        indexed: false
      },
      { name: "uri", internalType: "string", type: "string", indexed: false },
      { name: "name", internalType: "string", type: "string", indexed: false },
      {
        name: "symbol",
        internalType: "string",
        type: "string",
        indexed: false
      },
      {
        name: "coin",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "pool",
        internalType: "address",
        type: "address",
        indexed: false
      },
      {
        name: "version",
        internalType: "string",
        type: "string",
        indexed: false
      }
    ],
    name: "CoinCreated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "version",
        internalType: "uint64",
        type: "uint64",
        indexed: false
      }
    ],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "previousOwner",
        internalType: "address",
        type: "address",
        indexed: true
      },
      {
        name: "newOwner",
        internalType: "address",
        type: "address",
        indexed: true
      }
    ],
    name: "OwnershipTransferred"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "implementation",
        internalType: "address",
        type: "address",
        indexed: true
      }
    ],
    name: "Upgraded"
  },
  {
    type: "error",
    inputs: [{ name: "target", internalType: "address", type: "address" }],
    name: "AddressEmptyCode"
  },
  {
    type: "error",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "AddressInsufficientBalance"
  },
  { type: "error", inputs: [], name: "ERC1167FailedCreateClone" },
  {
    type: "error",
    inputs: [
      { name: "implementation", internalType: "address", type: "address" }
    ],
    name: "ERC1967InvalidImplementation"
  },
  { type: "error", inputs: [], name: "ERC1967NonPayable" },
  { type: "error", inputs: [], name: "ERC20TransferAmountMismatch" },
  { type: "error", inputs: [], name: "EthTransferInvalid" },
  { type: "error", inputs: [], name: "FailedInnerCall" },
  { type: "error", inputs: [], name: "InvalidInitialization" },
  { type: "error", inputs: [], name: "NotInitializing" },
  {
    type: "error",
    inputs: [{ name: "owner", internalType: "address", type: "address" }],
    name: "OwnableInvalidOwner"
  },
  {
    type: "error",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "OwnableUnauthorizedAccount"
  },
  { type: "error", inputs: [], name: "ReentrancyGuardReentrantCall" },
  {
    type: "error",
    inputs: [{ name: "token", internalType: "address", type: "address" }],
    name: "SafeERC20FailedOperation"
  },
  { type: "error", inputs: [], name: "UUPSUnauthorizedCallContext" },
  {
    type: "error",
    inputs: [{ name: "slot", internalType: "bytes32", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID"
  }
];
var zoraFactoryImplAddress = {
  8453: "0x777777751622c0d3258f214F9DF38E35BF45baF3",
  84532: "0x777777751622c0d3258f214F9DF38E35BF45baF3"
};

// node_modules/@hey-api/client-fetch/dist/index.js
var A = async (t, r) => {
  let e = typeof r == "function" ? await r(t) : r;
  if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
};
var R = { bodySerializer: (t) => JSON.stringify(t, (r, e) => typeof e == "bigint" ? e.toString() : e) };
var U = (t) => {
  switch (t) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var _ = (t) => {
  switch (t) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var D = (t) => {
  switch (t) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var O = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {
  if (!r) {
    let s = (t ? i : i.map((l) => encodeURIComponent(l))).join(_(a));
    switch (a) {
      case "label":
        return `.${s}`;
      case "matrix":
        return `;${e}=${s}`;
      case "simple":
        return s;
      default:
        return `${e}=${s}`;
    }
  }
  let o = U(a), n = i.map((s) => a === "label" || a === "simple" ? t ? s : encodeURIComponent(s) : y({ allowReserved: t, name: e, value: s })).join(o);
  return a === "label" || a === "matrix" ? o + n : n;
};
var y = ({ allowReserved: t, name: r, value: e }) => {
  if (e == null) return "";
  if (typeof e == "object") throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");
  return `${r}=${t ? e : encodeURIComponent(e)}`;
};
var q = ({ allowReserved: t, explode: r, name: e, style: a, value: i }) => {
  if (i instanceof Date) return `${e}=${i.toISOString()}`;
  if (a !== "deepObject" && !r) {
    let s = [];
    Object.entries(i).forEach(([f, u]) => {
      s = [...s, f, t ? u : encodeURIComponent(u)];
    });
    let l = s.join(",");
    switch (a) {
      case "form":
        return `${e}=${l}`;
      case "label":
        return `.${l}`;
      case "matrix":
        return `;${e}=${l}`;
      default:
        return l;
    }
  }
  let o = D(a), n = Object.entries(i).map(([s, l]) => y({ allowReserved: t, name: a === "deepObject" ? `${e}[${s}]` : s, value: l })).join(o);
  return a === "label" || a === "matrix" ? o + n : n;
};
var H = /\{[^{}]+\}/g;
var B = ({ path: t, url: r }) => {
  let e = r, a = r.match(H);
  if (a) for (let i of a) {
    let o = false, n = i.substring(1, i.length - 1), s = "simple";
    n.endsWith("*") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(".") ? (n = n.substring(1), s = "label") : n.startsWith(";") && (n = n.substring(1), s = "matrix");
    let l = t[n];
    if (l == null) continue;
    if (Array.isArray(l)) {
      e = e.replace(i, O({ explode: o, name: n, style: s, value: l }));
      continue;
    }
    if (typeof l == "object") {
      e = e.replace(i, q({ explode: o, name: n, style: s, value: l }));
      continue;
    }
    if (s === "matrix") {
      e = e.replace(i, `;${y({ name: n, value: l })}`);
      continue;
    }
    let f = encodeURIComponent(s === "label" ? `.${l}` : l);
    e = e.replace(i, f);
  }
  return e;
};
var E = ({ allowReserved: t, array: r, object: e } = {}) => (i) => {
  let o = [];
  if (i && typeof i == "object") for (let n in i) {
    let s = i[n];
    if (s != null) {
      if (Array.isArray(s)) {
        o = [...o, O({ allowReserved: t, explode: true, name: n, style: "form", value: s, ...r })];
        continue;
      }
      if (typeof s == "object") {
        o = [...o, q({ allowReserved: t, explode: true, name: n, style: "deepObject", value: s, ...e })];
        continue;
      }
      o = [...o, y({ allowReserved: t, name: n, value: s })];
    }
  }
  return o.join("&");
};
var P = (t) => {
  var _a;
  if (!t) return "stream";
  let r = (_a = t.split(";")[0]) == null ? void 0 : _a.trim();
  if (r) {
    if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
    if (r === "multipart/form-data") return "formData";
    if (["application/", "audio/", "image/", "video/"].some((e) => r.startsWith(e))) return "blob";
    if (r.startsWith("text/")) return "text";
  }
};
var I = async ({ security: t, ...r }) => {
  for (let e of t) {
    let a = await A(e, r.auth);
    if (!a) continue;
    let i = e.name ?? "Authorization";
    switch (e.in) {
      case "query":
        r.query || (r.query = {}), r.query[i] = a;
        break;
      case "cookie":
        r.headers.append("Cookie", `${i}=${a}`);
        break;
      case "header":
      default:
        r.headers.set(i, a);
        break;
    }
    return;
  }
};
var S = (t) => W({ baseUrl: t.baseUrl, path: t.path, query: t.query, querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : E(t.querySerializer), url: t.url });
var W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i }) => {
  let o = i.startsWith("/") ? i : `/${i}`, n = (t ?? "") + o;
  r && (n = B({ path: r, url: n }));
  let s = e ? a(e) : "";
  return s.startsWith("?") && (s = s.substring(1)), s && (n += `?${s}`), n;
};
var C = (t, r) => {
  var _a;
  let e = { ...t, ...r };
  return ((_a = e.baseUrl) == null ? void 0 : _a.endsWith("/")) && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;
};
var x = (...t) => {
  let r = new Headers();
  for (let e of t) {
    if (!e || typeof e != "object") continue;
    let a = e instanceof Headers ? e.entries() : Object.entries(e);
    for (let [i, o] of a) if (o === null) r.delete(i);
    else if (Array.isArray(o)) for (let n of o) r.append(i, n);
    else o !== void 0 && r.set(i, typeof o == "object" ? JSON.stringify(o) : o);
  }
  return r;
};
var h = class {
  constructor() {
    __publicField(this, "_fns");
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(r) {
    return this._fns.indexOf(r) !== -1;
  }
  eject(r) {
    let e = this._fns.indexOf(r);
    e !== -1 && (this._fns = [...this._fns.slice(0, e), ...this._fns.slice(e + 1)]);
  }
  use(r) {
    this._fns = [...this._fns, r];
  }
};
var T = () => ({ error: new h(), request: new h(), response: new h() });
var N = E({ allowReserved: false, array: { explode: true, style: "form" }, object: { explode: true, style: "deepObject" } });
var Q = { "Content-Type": "application/json" };
var w = (t = {}) => ({ ...R, headers: Q, parseAs: "auto", querySerializer: N, ...t });
var J = (t = {}) => {
  let r = C(w(), t), e = () => ({ ...r }), a = (n) => (r = C(r, n), e()), i = T(), o = async (n) => {
    let s = { ...r, ...n, fetch: n.fetch ?? r.fetch ?? globalThis.fetch, headers: x(r.headers, n.headers) };
    s.security && await I({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
    let l = S(s), f = { redirect: "follow", ...s }, u = new Request(l, f);
    for (let p of i.request._fns) u = await p(u, s);
    let k = s.fetch, c = await k(u);
    for (let p of i.response._fns) c = await p(c, u, s);
    let m = { request: u, response: c };
    if (c.ok) {
      if (c.status === 204 || c.headers.get("Content-Length") === "0") return { data: {}, ...m };
      let p = (s.parseAs === "auto" ? P(c.headers.get("Content-Type")) : s.parseAs) ?? "json";
      if (p === "stream") return { data: c.body, ...m };
      let b = await c[p]();
      return p === "json" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), { data: b, ...m };
    }
    let g = await c.text();
    try {
      g = JSON.parse(g);
    } catch {
    }
    let d = g;
    for (let p of i.error._fns) d = await p(g, c, u, s);
    if (d = d || {}, s.throwOnError) throw d;
    return { error: d, ...m };
  };
  return { buildUrl: S, connect: (n) => o({ ...n, method: "CONNECT" }), delete: (n) => o({ ...n, method: "DELETE" }), get: (n) => o({ ...n, method: "GET" }), getConfig: e, head: (n) => o({ ...n, method: "HEAD" }), interceptors: i, options: (n) => o({ ...n, method: "OPTIONS" }), patch: (n) => o({ ...n, method: "PATCH" }), post: (n) => o({ ...n, method: "POST" }), put: (n) => o({ ...n, method: "PUT" }), request: o, setConfig: a, trace: (n) => o({ ...n, method: "TRACE" }) };
};

// node_modules/@zoralabs/coins-sdk/dist/index.js
var COIN_FACTORY_ADDRESS = zoraFactoryImplAddress["8453"];
var SUPERCHAIN_WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
var USDC_WETH_POOLS_BY_CHAIN = {
  [base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};
var validateClientNetwork = (publicClient) => {
  var _a;
  const clientChainId = (_a = publicClient == null ? void 0 : publicClient.chain) == null ? void 0 : _a.id;
  if (clientChainId === base.id) {
    return;
  }
  if (clientChainId === baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};
function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  initialPurchaseWei = 0n,
  tickLower = -199200,
  platformReferrer = "0x0000000000000000000000000000000000000000"
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  const currency = "0x4200000000000000000000000000000000000006";
  return {
    abi: zoraFactoryImplABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      platformReferrer,
      currency,
      tickLower,
      initialPurchaseWei
    ],
    value: initialPurchaseWei
  };
}
function getCoinCreateFromLogs(receipt) {
  var _a;
  const eventLogs = parseEventLogs({
    abi: zoraFactoryImplABI,
    logs: receipt.logs
  });
  return (_a = eventLogs.find((log) => log.eventName === "CoinCreated")) == null ? void 0 : _a.args;
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const { request } = await publicClient.simulateContract({
    ...createCoinCall(call),
    account: walletClient.account
  });
  if (request.gas) {
    request.gas = request.gas * BigInt((options == null ? void 0 : options.gasMultiplier) ?? 100) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: deployment == null ? void 0 : deployment.coin,
    deployment
  };
}
async function simulateBuy({
  target,
  requestedOrderSize,
  publicClient
}) {
  const numberResult = await publicClient.simulateContract({
    address: target,
    abi: coinABI,
    functionName: "buy",
    args: [
      zeroAddress,
      requestedOrderSize,
      0n,
      // minAmountOut
      0n,
      // sqrtPriceLimitX96
      zeroAddress
      // tradeReferrer
    ],
    // We want to ensure that the multicall3 contract has enough ETH to buy in the simulation
    stateOverride: [
      {
        address: baseSepolia.contracts.multicall3.address,
        balance: parseEther("10000000")
      }
    ]
  });
  const orderSize = numberResult.result[0];
  const amountOut = numberResult.result[1];
  return { orderSize, amountOut };
}
function tradeCoinCall({
  target,
  direction,
  args: {
    recipient,
    orderSize,
    minAmountOut = 0n,
    sqrtPriceLimitX96 = 0n,
    tradeReferrer = zeroAddress
  }
}) {
  return {
    abi: coinABI,
    functionName: direction,
    address: target,
    args: [
      recipient,
      orderSize,
      minAmountOut,
      sqrtPriceLimitX96,
      tradeReferrer
    ],
    value: direction === "buy" ? orderSize : 0n
  };
}
function getTradeFromLogs(receipt, direction) {
  var _a, _b;
  const eventLogs = parseEventLogs({
    abi: coinABI,
    logs: receipt.logs
  });
  if (direction === "buy") {
    return (_a = eventLogs.find((log) => log.eventName === "CoinBuy")) == null ? void 0 : _a.args;
  }
  return (_b = eventLogs.find((log) => log.eventName === "CoinSell")) == null ? void 0 : _b.args;
}
async function tradeCoin(params, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const { request } = await publicClient.simulateContract({
    ...tradeCoinCall(params),
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const trade = getTradeFromLogs(receipt, params.direction);
  return {
    hash,
    receipt,
    trade
  };
}
async function getOnchainCoinDetails({
  coin,
  user = zeroAddress,
  publicClient
}) {
  var _a;
  validateClientNetwork(publicClient);
  const [balance, pool, owners, payoutRecipient] = await publicClient.multicall(
    {
      contracts: [
        {
          address: coin,
          abi: coinABI,
          functionName: "balanceOf",
          args: [user]
        },
        {
          address: coin,
          abi: coinABI,
          functionName: "poolAddress"
        },
        {
          address: coin,
          abi: coinABI,
          functionName: "owners"
        },
        {
          address: coin,
          abi: coinABI,
          functionName: "payoutRecipient"
        }
      ],
      allowFailure: false
    }
  );
  const USDC_WETH_POOL = USDC_WETH_POOLS_BY_CHAIN[((_a = publicClient.chain) == null ? void 0 : _a.id) || 0];
  const [
    coinWethPoolSlot0,
    coinWethPoolToken0,
    coinReservesRaw,
    coinTotalSupply,
    wethReservesRaw,
    usdcWethSlot0
  ] = await publicClient.multicall({
    contracts: [
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      },
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "token0"
      },
      {
        address: coin,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: coin,
        abi: coinABI,
        functionName: "totalSupply"
      },
      {
        address: SUPERCHAIN_WETH_ADDRESS,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: USDC_WETH_POOL ?? coin,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      }
    ],
    allowFailure: false
  });
  const wethPriceInUsdc = USDC_WETH_POOL ? uniswapV3SqrtPriceToBigIntScaled(
    usdcWethSlot0.sqrtPriceX96,
    18,
    6,
    true,
    18
  ) : null;
  const coinPriceInWeth = uniswapV3SqrtPriceToBigIntScaled(
    coinWethPoolSlot0.sqrtPriceX96,
    18,
    18,
    isAddressEqual(coinWethPoolToken0, coin),
    18
  );
  const marketCap = coinPriceInWeth * coinTotalSupply / 10n ** 18n;
  const wethLiquidity = wethReservesRaw;
  const tokenLiquidity = coinReservesRaw * coinPriceInWeth / 10n ** 18n;
  return {
    balance,
    pool,
    owners,
    payoutRecipient,
    marketCap: convertEthOutput(marketCap, wethPriceInUsdc),
    liquidity: convertEthOutput(
      wethLiquidity + tokenLiquidity,
      wethPriceInUsdc
    ),
    poolState: coinWethPoolSlot0
  };
}
function convertEthOutput(amountETH, wethToUsdc) {
  return {
    eth: amountETH,
    ethDecimal: parseFloat(formatEther(amountETH)),
    usdc: wethToUsdc ? amountETH * wethToUsdc : null,
    usdcDecimal: wethToUsdc ? parseFloat(formatEther(amountETH * wethToUsdc / 10n ** 18n)) : null
  };
}
function uniswapV3SqrtPriceToBigIntScaled(sqrtPriceX96, token0Decimals, token1Decimals, isToken0Coin, scaleDecimals = 18) {
  const numerator = sqrtPriceX96 * sqrtPriceX96;
  const denominator = 2n ** 192n;
  const scaleFactor = 10n ** BigInt(scaleDecimals);
  let ratioScaled = numerator * scaleFactor / denominator;
  const decimalsDiff = BigInt(token0Decimals - token1Decimals);
  if (decimalsDiff > 0n) {
    ratioScaled *= 10n ** decimalsDiff;
  } else if (decimalsDiff < 0n) {
    ratioScaled /= 10n ** -decimalsDiff;
  }
  if (!isToken0Coin) {
    if (ratioScaled === 0n) {
      return 0n;
    }
    ratioScaled = scaleFactor * scaleFactor / ratioScaled;
  }
  return ratioScaled;
}
function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: coinABI,
    address: coin,
    functionName: "setContractURI",
    args: [newURI]
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}
function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: coinABI,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient]
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}
var client = J(
  w({
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);
var getCoin = (options) => {
  return (options.client ?? client).get({
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (options.client ?? client).get({
    url: "/coinComments",
    ...options
  });
};
var getCoins = (options) => {
  return (options.client ?? client).get({
    url: "/coins",
    ...options
  });
};
var getExplore = (options) => {
  return (options.client ?? client).get({
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (options.client ?? client).get({
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (options.client ?? client).get({
    url: "/profileBalances",
    ...options
  });
};
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    meta: getApiKeyMeta()
  });
};
var getCoins2 = async ({ coinAddresses, chainId }, options) => {
  return await getCoins({
    query: {
      coins: coinAddresses.map((collectionAddress) => ({
        chainId,
        collectionAddress
      }))
    },
    meta: getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  meta: getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    throw new Error("Data URIs are not supported");
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata && typeof metadata.animation_url !== "string") {
    throw new Error("Metadata animation_url, if provided, must be a string");
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}
export {
  cleanAndValidateMetadataURI,
  createCoin,
  createCoinCall,
  getCoin2 as getCoin,
  getCoinComments2 as getCoinComments,
  getCoinCreateFromLogs,
  getCoins2 as getCoins,
  getCoinsLastTraded,
  getCoinsLastTradedUnique,
  getCoinsMostValuable,
  getCoinsNew,
  getCoinsTopGainers,
  getCoinsTopVolume24h,
  getOnchainCoinDetails,
  getProfile2 as getProfile,
  getProfileBalances2 as getProfileBalances,
  getTradeFromLogs,
  setApiKey,
  simulateBuy,
  tradeCoin,
  tradeCoinCall,
  updateCoinURI,
  updateCoinURICall,
  updatePayoutRecipient,
  updatePayoutRecipientCall,
  validateMetadataJSON,
  validateMetadataURIContent
};
//# sourceMappingURL=@zoralabs_coins-sdk.js.map
